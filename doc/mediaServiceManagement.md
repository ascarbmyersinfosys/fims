![FIMS logo](./FIMS_logo.png) ![EBU logo](./EBU_logo.svg.png) __EBU Tech 3356__ ![AMWA_logo](./AMWA_logo.png)
# Specification of the FIMS Media SOA Framework
### General Description - Version 1.3

_Previous_: [High-level architectures](./high-levelArchitectures.md) | _Up_: [Contents](./introduction.md) | _Next_: [Media service awareness](./mediaServiceAwareness.md)

## Media service management

### Service lifecycle

The main lifecycle states of a service are:

* Service deployed
* Service updated
* Service replaced
* Service decommissioned

#### Deployment

A service is deployed when the new service or service instance is registered in the service registry. The information 
provided in the registry includes:

*	Service interfaces.
*	Service endpoint information.
*	Service description metadata.
*	Service policies.

#### Decomissioning

Decommissioning services from the environment is supported by the service registry, which allows the system administrators 
to first deprecate existing implementations so that potential new consumers do not see the specific implementation. 
Administrators can then use reporting and impact analysis capabilities in the service registry to allow the operations 
team to identify remaining service version consumers and ensure that they migrate onto the correct alternative version. 
After all of the consumers have been migrated, the old service version can be retired from use and removed from the
environment.

#### Replacement / upgrade

A service can be updated or replaced by updating the service information in the service registry.

The service interfaces and schemas as specified in this FIMS specification shall not require updating if a service is 
replaced by one providing the same business functionality with the same version of the interface. However, as FIMS 
specifications evolve, new versions of an interface may be published and may need to be updated in the registry. As 
service versions are superseded by new implementations which deliver the same required business capability, the service 
governance lifecycle should allow older versions to be deprecated and, ultimately, retired.

#### FIMS interface versioning

Backward compatibility issues might arise for a variety of reasons. This version of the specification focuses on two 
scenarios:

* There is a new version of the FIMS specifications for a service interface or base schemas.
* A service implementation has been modified for adding or removing features (such as operations).

##### New version of interfaces

From time to time, the FIMS technical board will issue new versions of the FIMS normative schemas and associated 
specifications with a common, incremented version number. Although every effort will be made to make new minor 
version updated to be backwards compatible with previous versions, the nature of FIMS as a bi-directional communication 
framework causes unavoidable issues for implementers, including:

* Mismatched versions of data between that sent to a service and received in a synchronous response; 
* Similarly for notifications sent from services;
* Use of runtime validation and/or auto-generated code that is specific to a schema version.

Services and orchestration systems are not required to provide simultaneous support for multiple versions of FIMS. A 
single service endpoint shall provide support for one and only one version of the FIMS schemas and specifications. A 
service may support more than one version of the FIMS specification through the provisioning of additional endpoints, 
one per version.

The FIMS base services schema contains a simple type called "CurrentVersion" that shall be a string value restricted 
to contain a single value equal to the version number of the schema. For example, the fixed value is "v1_2_0" for FIMS 
version 1.2.

With the exception of FIMS v1.0.7 messages, all FIMS SOAP request messages, response messages, notification messages 
and event messages shall indicate their version number using a mandatory attribute named "version" of "CurrentVersion" 
type. A response message or notification message generated by a service endpoint shall have the same version number as 
that of the endpoint, thereby ensuring that servers and clients support the same version.

As the version attribute was not present in FIMS version 1.0.7, any SOAP request, response or notification message 
that does not contain a version attribute shall be treated as a FIMS 1.0.7 message.

All FIMS REST messages other than fault messages shall contain a mandatory header named "X-FIMS-Version" with a value 
set to the same as the version number of the specification as the fixed value of the "CurrentVersion" simple type.

> Note: No FIMS REST mapping was defined for FIMS 1.0.7, so the legacy issue of a missing version attribute is not an 
  issue for REST services.

So that both REST and SOAP services may receive version-related fault messages, fault messages shall not have a 
version number.

For REST services, if the version number of a message is not supported by the receiving endpoint, it shall be rejected 
with a fault response using code "SVC_S00_0019", indicating a version mismatch. To enable the consumer of the endpoint 
to change the version of their request or route the message to an appropriate endpoint, the fault's message should 
contain details of the current version supported by the endpoint. 

For SOAP services, if it is not possible to differentiate a version mismatch from an invalid XML instance of an xml 
schema, it is recommended that all fault responses with code "DAT_S00_0001" should explicitly state the current version 
of the service in either the description or the detail part of the fault message.

> Note:	It is anticipated that translation endpoint services can be implemented to help users with the process of 
  migration from one version to the next.
  
##### New service implementation

In this scenario there is no change in the version of the interface, but the service is replaced with a different 
implementation in which either only some of the features (e.g. operations) are implemented or additional new features 
are implemented. In the latter case, the service is backward compatible. In the former case, there is the issue of 
making the framework aware that the service is not implementing some features.

The following practices shall be followed:

* Service description for each service implementation provides a list of available service operations and properties 
  (e.g., a transform operation provides a list of supported formats).
* A new service may be invoked through mediation in the ESB or via an orchestration system, in which case a lookup in 
  the service registry can be used to find the service instance(s) that implement the requested operation.

### Job management

#### Lifecycle of a job

The figure below shows the states associated to a long-running job since its request until its completion, cancellation 
or failure. It also shows the job commands or actions that initiates a transition to a new state.

<img src="./state_chart.png" alt="UML statechart for a long-running job" width="100%"/>

The thick outlines to the circles in the figure above indicate the mandatory states that shall be implemented.

When a job request is received by a service its initial state is either _New_ or _Running_. In the _New_ or _Queued_ state, 
a job may have its priority changed before starting its execution through external job management commands (if the service 
supports these features). The job may also be cancelled by an external command. Once the job is de-queued for execution 
it moves to the _Scheduled_ state and when the scheduled time comes, it moves to the _Running_ state. In case the service 
does not implement the job queue, the job goes directly to the _Running_ state upon the arrival of a request.

The _Running_ state indicates a job is being executed. An external command may pause the job (and resume it later). The 
request may also be restarted or cancelled by external commands. Restarting means to start its execution again. If a 
job executes until its completion it transitions to the _Completed_ state. If an error occurs during its execution it moves 
to the _Failed_ state. An external command may force the early termination of a job execution. To stop a job means to force 
its completion. This is not an error situation and the result of the job processing until that moment is considered to 
be the result of the job execution.

Media services often produce large media files that need to be available until the client or other services retrieve them. 
Once the job completes (or it is stopped) the resulting product of the operation shall be kept by the service. An external 
(or internal) command (cleanup) is used to indicate to the service that the result is no longer needed and the job 
transitions then to _Cleaned_ state. Services may independently move jobs to the _Cleaned_ state after an elapsed time, 
the duration of which is to be determined by the service. Services shall be responsible for cleaning jobs across service 
stop or crash events.

The transition to _Cancelled_, _Completed_, _Stopped_ and _Failed_ states shall produce a notification to the endpoints 
specified at the _notifyAt_ parameter of the request message, if a notification is expected at the end of the job execution 
or at the job cancellation. _Completed_, _Stopped_ and _Cancelled_ shall produce a response notification message to the 
_replyTo_ endpoint, while _Failed_ shall produce an error notification message addressed to the _faultTo_ endpoint.

The _Unknown_ state indicates the job is currently being processed but its state cannot be obtained.

#### Management commands

The FIMS services interfaces provide three job management operations. They are the manageJob, manageQueue and queryJob 
operations, as shown in the figure below.

<img src="job_manage_ops.png" alt="Job management operations" width="60%"/>

* * *

_Previous_: [High-level architectures](./high-levelArchitectures.md) | _Up_: [Contents](./introduction.md) | _Next_: [Media service awareness](./mediaServiceAwareness.md)

Copyright 2015 European Broadcasting Union

Copyright 2015 Advanced Media Workflow Association
